import { CancelablePromise } from './promise';
/**
 * Wellknown "timer" IDs used when scheduling delayed operations on the
 * AsyncQueue. These IDs can then be used from tests to check for the presence
 * of operations or to run them early.
 */
export declare enum TimerId {
    ListenStreamIdle = 0,
    ListenStreamConnection = 1,
    WriteStreamIdle = 2,
    WriteStreamConnection = 3,
}
export declare class AsyncQueue {
    private tail;
    private delayedOperations;
    failure: Error;
    private operationInProgress;
    /**
     * Adds a new operation to the queue. Returns a promise that will be resolved
     * when the promise returned by the new operation is (with its value).
     */
    enqueue<T>(op: () => Promise<T>): Promise<T>;
    /**
     * Schedules an operation to be queued on the AsyncQueue once the specified
     * `delayMs` has elapsed. The returned CancelablePromise can be used to cancel
     * the operation prior to its running.
     */
    enqueueAfterDelay<T>(timerId: TimerId, delayMs: number, op: () => Promise<T>): CancelablePromise<T>;
    private verifyNotFailed();
    /**
     * Verifies there's an operation currently in-progress on the AsyncQueue.
     * Unfortunately we can't verify that the running code is in the promise chain
     * of that operation, so this isn't a foolproof check, but it should be enough
     * to catch some bugs.
     */
    verifyOperationInProgress(): void;
    /**
     * Waits until all currently queued tasks are finished executing. Delayed
     * operations are not run.
     */
    drain(): Promise<void>;
    /**
     * For Tests: Determine if a delayed operation with a particular TimerId
     * exists.
     */
    containsDelayedOperation(timerId: TimerId): boolean;
    /**
     * For Tests: Runs some or all delayed operations early.
     *
     * @param lastTimerId If specified, only delayed operations up to and
     *   including this TimerId will be drained. Throws if no such operation
     *   exists.
     * @returns a Promise that resolves once all operations have been run.
     */
    runDelayedOperationsEarly(lastTimerId?: TimerId): Promise<void>;
    /** Called once a DelayedOperation is run or canceled. */
    private removeDelayedOperation<T>(op);
}
